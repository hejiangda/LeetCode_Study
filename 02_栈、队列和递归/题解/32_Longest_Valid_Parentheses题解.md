# Longest Valid Parentheses（最长有效的括号）题解

- [Longest Valid Parentheses（最长有效的括号）](https://leetcode-cn.com/problems/longest-valid-parentheses/)

这一题想了很久，一开始找到了一个与当前左括号匹配数相关的解法，然而这个方法会遇到各种条件限制，会越写越复杂。

之后想到可以把匹配的左右括号用1表示，而未匹配的用0表示，然后只要找出整个数串连续为1的最大个数即可。

[LeetCode题解](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/)

不得不说，官方的题解太牛逼了！
## 用栈求

求最长有效括号，则当栈顶的括号匹配时说明两者中间的括号也是匹配的（因为只考虑圆括号！！！则出现括号只有两种结果：左括号被压栈、右括号匹配出栈）这样就可以使用括号的索引相减直接得到两者的间距。

## 不需要额外空间

用两个计数器，先从左往右遍历，记录左右括号的个数，当两者相等即这部分括号已经匹配记录两者和，当右括号大于左括号时重置（此时的括号串不可能匹配了例如：(()()))()）再从右往左遍历，只不过这时当左括号大于右括号时重置。

分别从左和右遍历是为了防止孤立的括号对匹配的影响。如(()))|()()()，若只从左往右则右侧匹配的括号无法被匹配。这方法太牛逼了！！

## 动态规划法

我们定义一个 dp 数组，其中第 i 个元素表示以下标为 i 的字符结尾的最长有效子字符串的长度。这个方法也很巧妙！！

